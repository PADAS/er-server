""" Support for MBTiles file format, version 1.1.

source: https://github.com/TileStache
        TileStache/TileStache/MBTiles.py
        License BSD

        Landez for MBTilesReader and Projections

MBTiles (http://mbtiles.org) is a specification for storing tiled map data in
SQLite databases for immediate use and for transfer. The files are designed for
portability of thousands, hundreds of thousands, or even millions of standard
map tile images in a single file.

This makes it easy to manage and share map tiles.

Read the spec:
    https://github.com/mapbox/mbtiles-spec/blob/master/1.1/spec.md

MBTiles files generated by other applications such as Tilemill or Arc2Earth
can be used as data sources for the MBTiles Provider.

Example configuration:

  {
    "cache": { ... }.
    "layers":
    {
      "roads":
      {
        "provider":
        {
          "name": "mbtiles",
          "tileset": "collection.mbtiles"
        }
      }
    }
  }

MBTiles provider parameters:

  tileset:
    Required local file path to MBTiles tileset file, a SQLite 3 database file.
"""
import json
import logging
import math
import os
# Heroku is missing standard python's sqlite3 package, so this will ImportError.
import sqlite3
import zlib
from os.path import exists
from sqlite3 import connect as _connect
from urllib.parse import urljoin, urlparse

from django.http.response import HttpResponse
from django.utils.translation import gettext_lazy as _

from mapping import app_settings
from mapping.proj import GoogleProjection

logger = logging.getLogger(__name__)


class ExtractionError(Exception):
    """ Raised when extraction of tiles from specified MBTiles has failed """


class InvalidFormatError(Exception):
    """ Raised when reading of MBTiles content has failed """


def flip_y(y, z):
    return 2 ** z - 1 - y


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return '(%(x).3f, %(y).3f)' % self.__dict__


class Coordinate:
    MAX_ZOOM = 25

    def __init__(self, row, column, zoom):
        self.row = row
        self.column = column
        self.zoom = zoom

    def __repr__(self):
        return '(%(row).3f, %(column).3f @%(zoom).3f)' % self.__dict__

    def __eq__(self, other):
        return self.zoom == other.zoom and self.row == other.row and self.column == other.column

    def __lt__(self, other):
        return (self.zoom, self.row, self.column) < (other.zoom, other.row, other.column)

    def __hash__(self):
        return hash(('Coordinate', self.row, self.column, self.zoom))

    def copy(self):
        return self.__class__(self.row, self.column, self.zoom)

    def container(self):
        return self.__class__(math.floor(self.row), math.floor(self.column), self.zoom)

    def zoomTo(self, destination):
        return self.__class__(self.row * math.pow(2, destination - self.zoom),
                              self.column *
                              math.pow(2, destination - self.zoom),
                              destination)

    def zoomBy(self, distance):
        return self.__class__(self.row * math.pow(2, distance),
                              self.column * math.pow(2, distance),
                              self.zoom + distance)

    def up(self, distance=1):
        return self.__class__(self.row - distance, self.column, self.zoom)

    def right(self, distance=1):
        return self.__class__(self.row, self.column + distance, self.zoom)

    def down(self, distance=1):
        return self.__class__(self.row + distance, self.column, self.zoom)

    def left(self, distance=1):
        return self.__class__(self.row, self.column - distance, self.zoom)


def tileset_exists(filename):
    """ Return true if the tileset exists and appears to have the right tables.
    """
    if not exists(filename):
        return False

    # this always works
    db = _connect(filename)
    db.text_factory = bytes

    try:
        db.execute('SELECT name, value FROM metadata LIMIT 1')
        db.execute(
            'SELECT zoom_level, tile_column, tile_row, tile_data FROM tiles LIMIT 1')
    except:
        return False

    return True


def tileset_info(filename):
    """ Return name, type, version, description, format, and bounds for a tileset.

        Returns None if tileset does not exist.
    """
    if not tileset_exists(filename):
        return None

    db = _connect(filename)
    db.text_factory = bytes

    info = []

    for key in ('name', 'type', 'version', 'description', 'format', 'bounds'):
        value = db.execute(
            'SELECT value FROM metadata WHERE name = ?', (key, )).fetchone()
        info.append(value and value[0] or None)

    return info


def list_tiles(filename):
    """ Get a list of tile coordinates.
    """
    db = _connect(filename)
    db.text_factory = bytes

    tiles = db.execute('SELECT tile_row, tile_column, zoom_level FROM tiles')
    # Hello, Paul Ramsey.
    tiles = (((2**z - 1) - y, x, z) for (y, x, z) in tiles)
    tiles = [Coordinate(row, column, zoom) for (row, column, zoom) in tiles]

    return tiles


def get_tile(filename, coord):
    """ Retrieve the mime-type and raw content of a tile by coordinate.

        If the tile does not exist, None is returned for the content.
    """
    db = _connect(filename)
    db.text_factory = bytes

    formats = {'png': 'image/png', 'jpg': 'image/jpeg',
               'json': 'application/json', None: None}
    format = db.execute(
        "SELECT value FROM metadata WHERE name='format'").fetchone()
    format = format and format[0] or None
    mime_type = formats[format]

    tile_row = (2**coord.zoom - 1) - coord.row  # Hello, Paul Ramsey.
    q = 'SELECT tile_data FROM tiles WHERE zoom_level=? AND tile_column=? AND tile_row=?'
    content = db.execute(q, (coord.zoom, coord.column, tile_row)).fetchone()
    content = content and content[0] or None

    return mime_type, content


class Provider:
    """ MBTiles provider.

        See module documentation for explanation of constructor arguments.
    """

    def __init__(self, layer, tileset):
        """
        """
        sethref = urljoin(layer.config.dirpath, tileset)
        scheme, h, path, q, p, f = urlparse(sethref)

        if scheme not in ('file', ''):
            raise Exception(
                'Bad scheme in MBTiles provider, must be local file: "%s"' % scheme)

        self.tileset = path
        self.layer = layer

    @staticmethod
    def prepareKeywordArgs(config_dict):
        """ Convert configured parameters to keyword args for __init__().
        """
        return {'tileset': config_dict['tileset']}

    def renderTile(self, width, height, srs, coord):
        """ Retrieve a single tile, return a TileResponse instance.
        """
        mime_type, content = get_tile(self.tileset, coord)
        formats = {'image/png': 'PNG', 'image/jpeg': 'JPEG',
                   'application/json': 'JSON', None: None}
        return TileResponse(formats[mime_type], content)

    def getTypeByExtension(self, extension):
        """ Get mime-type and format by file extension.

            This only accepts "png" or "jpg" or "json".
        """
        if extension.lower() == 'json':
            return 'application/json', 'JSON'

        elif extension.lower() == 'png':
            return 'image/png', 'PNG'

        elif extension.lower() == 'jpg':
            return 'image/jpg', 'JPEG'

        else:
            raise HttpResponse(reason='MBTiles only makes .png and .jpg and .json tiles, not "%s"' % extension,
                               status_code=406)


class TileResponse:
    """ Wrapper class for tile response that makes it behave like a PIL.Image object.

        TileStache.getTile() expects to be able to save one of these to a buffer.

        Constructor arguments:
        - format: 'PNG' or 'JPEG'.
        - content: Raw response bytes.
    """

    def __init__(self, format, content):
        self.format = format
        self.content = content

    def save(self, out, format):
        if self.format is not None and format != self.format:
            raise Exception('Requested format "%s" does not match tileset format "%s"' % (
                format, self.format))

        out.write(self.content)


class TileSource(object):
    def __init__(self, tilesize=None):
        if tilesize is None:
            tilesize = app_settings.MBTILES['tile_size']
        self.tilesize = tilesize
        self.basename = ''

    def tile(self, z, x, y):
        raise NotImplementedError

    def metadata(self):
        return dict()


class MBTilesReader(TileSource):
    def __init__(self, filename, tilesize=None):
        super(MBTilesReader, self).__init__(tilesize)
        self.filename = filename
        self.basename = os.path.basename(self.filename)
        self._con = None
        self._cur = None

    def _query(self, sql, *args):
        """ Executes the specified `sql` query and returns the cursor """
        if not self._con:
            logger.debug(_("Open MBTiles file '%s'") % self.filename)
            self._con = sqlite3.connect(self.filename)
            self._cur = self._con.cursor()
        sql = ' '.join(sql.split())
        logger.debug(_("Execute query '%s' %s") % (sql, args))
        try:
            self._cur.execute(sql, *args)
        except (sqlite3.OperationalError, sqlite3.DatabaseError) as e:
            raise InvalidFormatError(
                _("%s while reading %s") % (e, self.filename))
        return self._cur

    def metadata(self):
        rows = self._query('SELECT name, value FROM metadata')
        rows = [(row[0], row[1]) for row in rows]
        return dict(rows)

    def zoomlevels(self):
        rows = self._query(
            'SELECT DISTINCT(zoom_level) FROM tiles ORDER BY zoom_level')
        return [int(row[0]) for row in rows]

    def tile(self, z, x, y):
        logger.debug(_("Extract tile %s") % ((z, x, y),))
        tms_y = flip_y(int(y), int(z))
        rows = self._query('''SELECT tile_data FROM tiles
                              WHERE zoom_level=? AND tile_column=? AND tile_row=?;''', (z, x, tms_y))
        t = rows.fetchone()
        if not t:
            raise ExtractionError(
                _("Could not extract tile %s from %s") % ((z, x, y), self.filename))
        return t[0]

    def grid(self, z, x, y, callback=None):
        tms_y = flip_y(int(y), int(z))
        rows = self._query('''SELECT grid FROM grids
                              WHERE zoom_level=? AND tile_column=? AND tile_row=?;''', (z, x, tms_y))
        t = rows.fetchone()
        if not t:
            raise ExtractionError(
                _("Could not extract grid %s from %s") % ((z, x, y), self.filename))
        grid_json = json.loads(zlib.decompress(t[0]))

        rows = self._query('''SELECT key_name, key_json FROM grid_data
                              WHERE zoom_level=? AND tile_column=? AND tile_row=?;''', (z, x, tms_y))
        # join up with the grid 'data' which is in pieces when stored in mbtiles file
        grid_json['data'] = {}
        grid_data = rows.fetchone()
        while grid_data:
            grid_json['data'][grid_data[0]] = json.loads(grid_data[1])
            grid_data = rows.fetchone()
        serialized = json.dumps(grid_json)
        if callback is not None:
            return '%s(%s);' % (callback, serialized)
        return serialized

    def find_coverage(self, zoom):
        """
        Returns the bounding box (minx, miny, maxx, maxy) of an adjacent
        group of tiles at this zoom level.
        """
        # Find a group of adjacent available tiles at this zoom level
        rows = self._query('''SELECT tile_column, tile_row FROM tiles
                              WHERE zoom_level=?
                              ORDER BY tile_column, tile_row;''', (zoom,))
        t = rows.fetchone()
        xmin, ymin = t
        previous = t
        while t and t[0] - previous[0] <= 1:
            # adjacent, go on
            previous = t
            t = rows.fetchone()
        xmax, ymax = previous
        # Transform (xmin, ymin) (xmax, ymax) to pixels
        S = self.tilesize
        bottomleft = (xmin * S, (ymax + 1) * S)
        topright = ((xmax + 1) * S, ymin * S)
        # Convert center to (lon, lat)
        proj = GoogleProjection(S, [zoom])  # WGS84
        return proj.unproject_pixels(bottomleft, zoom) + proj.unproject_pixels(topright, zoom)
